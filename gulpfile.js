const { task, series, src, dest } = require('gulp'),
	fs = require('fs'),
	os = require('os'),
	crypto = require('crypto'),
	path = require('path'),
	args = require('yargs').argv,
	extract = require('extract-zip'),
	del = require('del'),
	copy = require('recursive-copy'),
	htmlmin = require('gulp-htmlmin'),
	dom = require("gulp-jsdom");

const config = {
	"theme_zip": "./ex-misc.webflow.zip",
	"theme_extract_dir": os.tmpdir() + '/webflow/' + crypto.randomBytes(16).toString('hex'),
	"publish_dir": args.target || 'dist',
	"copy_filter": [
		'css/*',
		'fonts/*',
		'js/*',
		'images/prefix_*',
		'images/favicon*',
		'images/webclip*',
		'index.html'
	],
	"custom_dir": ['custom', 'vendors'],
	"minifier": {
		"pages": ['index.html'],
		"base_url": "https://example.com.tw/",
		"url_replace": {
			"https://cdn.jsdelivr.net/npm/ramda@0.27.0/dist/ramda.min.js": "vendors/js/ramda.min.js"
		}
	}
};
const Color = {
	Reset: "\x1b[0m",
	Bright: "\x1b[1m",
	Dim: "\x1b[2m",
	Underscore: "\x1b[4m",
	Blink: "\x1b[5m",
	Reverse: "\x1b[7m",
	Hidden: "\x1b[8m",

	FgBlack: "\x1b[30m",
	FgRed: "\x1b[31m",
	FgGreen: "\x1b[32m",
	FgYellow: "\x1b[33m",
	FgBlue: "\x1b[34m",
	FgMagenta: "\x1b[35m",
	FgCyan: "\x1b[36m",
	FgWhite: "\x1b[37m",

	BgBlack: "\x1b[40m",
	BgRed: "\x1b[41m",
	BgGreen: "\x1b[42m",
	BgYellow: "\x1b[43m",
	BgBlue: "\x1b[44m",
	BgMagenta: "\x1b[45m",
	BgCyan: "\x1b[46m",
	BgWhite: "\x1b[47m"
}

function colorString(color, str) {
	return `${color}${str}${Color.Reset}`;
}

function colorLog(color, ...args) {
	console.log(...args.map(
		(it) => typeof it === "string" ? colorString(color, it) : it
	));
}
async function copyFiles(src, target, filter = null) {
	return copy(src, path.join(__dirname, target), {
		overwrite: true,
		expand: true,
		dot: true,
		junk: true,
		filter: filter
	})
		.then(function (results) {
			console.info('Copied ' + results.length + ' files');
		})
		.catch(function (error) {
			console.error('Copy failed: ' + error);
			process.exit();
		});
}
//解壓縮到暫存資料夾
task('extract zip', async function (done) {
	try {
		await extract(config.theme_zip, { dir: config.theme_extract_dir });
		done();
	} catch (err) {
		console.error(err);
		process.exit();
	}
});
//建立發布資料夾
task('create publish dir', function (done) {
	fs.mkdir(path.join(__dirname, config.publish_dir), { recursive: true }, (err) => err ? console.error(err) : '');
	done();
});
//複製發布設定檔
task('copy toml', function (done) {
	fs.copyFile("./netlify.toml", `./${config.publish_dir}/netlify.toml`, function (e) { });
	done();
});
//複製自訂程式
task('copy custom dir', function (done) {
	config.custom_dir.forEach(async dir => {
		await copyFiles(path.join(__dirname, dir), `${config.publish_dir}/${dir}`);
	});
	done();
});
//由暫存資料夾複製到發佈資料夾
task('copy web', async function (done) {
	await copyFiles(config.theme_extract_dir, config.publish_dir, config.copy_filter);
	done();
});
//整理html
task('html process', async function (done) {
	config.minifier.pages.forEach(page => {
		src(`${config.publish_dir}/${page}`)
			.pipe(htmlmin({//minify
				collapseWhitespace: true,
				removeComments: true,
				minifyJS: true,
				minifyCSS: true,
				includeAutoGeneratedTags: false,
				minifyURLs: url => {
					if (config.minifier.url_replace.hasOwnProperty(url)) {
						return config.minifier.url_replace[url];
					}
					if (url.startsWith(config.minifier.base_url)) {
						return url.replace(config.minifier.base_url, "");
					}
					return url;
				}
			}))
			.pipe(dom(document => {//移除webflow跨域資源設定
				let t = document.querySelectorAll('[crossorigin]');
				document.querySelectorAll('[crossorigin]').forEach(function (el) {
					el.removeAttribute('integrity');
					el.removeAttribute('crossorigin');
				});
			}))
			.pipe(dest(config.publish_dir));
	});
	done();
});
//清除暫存資料
task('clean', () => {
	return del([config.theme_extract_dir]);
});

task('default', series('extract zip', 'create publish dir', 'copy custom dir', 'copy web', 'html process', 'copy toml'));

